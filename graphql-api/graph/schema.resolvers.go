package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"fmt"
	"graphql-api/graph/model"
	"sync/atomic"
)

// CreateProfile is the resolver for the createProfile field.
func (r *mutationResolver) CreateProfile(ctx context.Context, input model.NewProfile) (*model.Profile, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Проверка существования компании, если указан companyId
	if input.CompanyID != nil {
		if _, exists := r.companies[int32(*input.CompanyID)]; !exists {
			return nil, fmt.Errorf("company with id %d not found", *input.CompanyID)
		}
	}

	id := atomic.AddInt32(&r.nextID.profile, 1)
	var companyID *int32
	var company *model.Company
	if input.CompanyID != nil {
		val := int32(*input.CompanyID)
		companyID = &val
		company = r.companies[val]
	}

	profile := &model.Profile{
		ID:        id,
		Name:      input.Name,
		Email:     input.Email,
		CompanyID: companyID,
		Company:   company,
	}

	r.profiles[id] = profile
	return profile, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfile) (*model.Profile, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.profiles[int32(input.ID)]; !exists {
		return nil, fmt.Errorf("profile with id %d not found", input.ID)
	}

	// Проверка существования компании, если указан companyId
	if input.CompanyID != nil {
		if _, exists := r.companies[int32(*input.CompanyID)]; !exists {
			return nil, fmt.Errorf("company with id %d not found", *input.CompanyID)
		}
	}

	var company *model.Company
	if input.CompanyID != nil {
		company = r.companies[int32(*input.CompanyID)]
	}

	profile := &model.Profile{
		ID:        int32(input.ID),
		Name:      input.Name,
		Email:     input.Email,
		CompanyID: input.CompanyID,
		Company:   company,
	}

	r.profiles[int32(input.ID)] = profile
	return profile, nil
}

// DeleteProfile is the resolver for the deleteProfile field.
func (r *mutationResolver) DeleteProfile(ctx context.Context, id int32) (bool, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.profiles[id]; !exists {
		return false, fmt.Errorf("profile with id %d not found", id)
	}

	delete(r.profiles, id)
	return true, nil
}

// CreateCompany is the resolver for the createCompany field.
func (r *mutationResolver) CreateCompany(ctx context.Context, input model.NewCompany) (*model.Company, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	id := atomic.AddInt32(&r.nextID.company, 1)
	company := &model.Company{
		ID:      id,
		Name:    input.Name,
		Address: input.Address,
	}

	r.companies[id] = company
	return company, nil
}

// UpdateCompany is the resolver for the updateCompany field.
func (r *mutationResolver) UpdateCompany(ctx context.Context, input model.UpdateCompany) (*model.Company, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.companies[int32(input.ID)]; !exists {
		return nil, fmt.Errorf("company with id %d not found", input.ID)
	}

	company := &model.Company{
		ID:      int32(input.ID),
		Name:    input.Name,
		Address: input.Address,
	}

	r.companies[int32(input.ID)] = company
	return company, nil
}

// DeleteCompany is the resolver for the deleteCompany field.
func (r *mutationResolver) DeleteCompany(ctx context.Context, id int32) (bool, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.companies[id]; !exists {
		return false, fmt.Errorf("company with id %d not found", id)
	}

	// Проверяем, есть ли сотрудники в этой компании
	for _, profile := range r.profiles {
		if profile.CompanyID != nil && int32(*profile.CompanyID) == id {
			return false, fmt.Errorf("cannot delete company: it has associated employees")
		}
	}

	delete(r.companies, id)
	return true, nil
}

// Profile is the resolver for the profile field.
func (r *queryResolver) Profile(ctx context.Context, id int32) (*model.Profile, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	profile, exists := r.profiles[id]
	if !exists {
		return nil, fmt.Errorf("profile with id %d not found", id)
	}

	return profile, nil
}

// Profiles is the resolver for the profiles field.
func (r *queryResolver) Profiles(ctx context.Context) ([]*model.Profile, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	profiles := make([]*model.Profile, 0, len(r.profiles))
	for _, profile := range r.profiles {
		profiles = append(profiles, profile)
	}
	return profiles, nil
}

// Company resolvers
func (r *queryResolver) Company(ctx context.Context, id int32) (*model.Company, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	company, exists := r.companies[id]
	if !exists {
		return nil, fmt.Errorf("company with id %d not found", id)
	}

	return company, nil
}

// Companies is the resolver for the companies field.
func (r *queryResolver) Companies(ctx context.Context) ([]*model.Company, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	companies := make([]*model.Company, 0, len(r.companies))
	for _, company := range r.companies {
		companies = append(companies, company)
	}
	return companies, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *Resolver) Profile() ProfileResolver { return &profileResolver{r} }
func (r *Resolver) Company() CompanyResolver { return &companyResolver{r} }
type profileResolver struct{ *Resolver }
type companyResolver struct{ *Resolver }
func (r *profileResolver) Company(ctx context.Context, obj *model.Profile) (*model.Company, error) {
	if obj.CompanyID == nil {
		return nil, nil
	}

	r.mu.RLock()
	defer r.mu.RUnlock()

	company, exists := r.companies[*obj.CompanyID]
	if !exists {
		return nil, fmt.Errorf("company with id %d not found", *obj.CompanyID)
	}

	return company, nil
}
func (r *companyResolver) Employees(ctx context.Context, obj *model.Company) ([]*model.Profile, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	var employees []*model.Profile
	for _, profile := range r.profiles {
		if profile.CompanyID != nil && *profile.CompanyID == obj.ID {
			employees = append(employees, profile)
		}
	}

	return employees, nil
}
*/
